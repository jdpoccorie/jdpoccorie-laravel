# Migraciones

## Conexión base de datos

Para poder conectarnosa una base de datos lo primero es tener la base de datos, para eso podemo crear uno en cualquier sistema de bases de datos como por ejemplo:
- MariaDB
- SQLServer
- MySQL
- PostgreSQL

Laravel tienen un archivo de configuraciones para las bases de datos, su ruta es la siguiente: `config/database.php`

Lo primero es establecer la base de datos a donde nos conectaremos
```php
'default' => env('DB_CONNECTION', 'mysql')
```

Lo que sigue es llenar la configuraciones necesarias de la conexión, en el mismo archivo:
```php
'mysql' => [
  'driver' => 'mysql',
  'url' => env('DATABASE_URL'),
  'host' => env('DB_HOST', '127.0.0.1'),
  'port' => env('DB_PORT', '3306'),
  'database' => env('DB_DATABASE', 'forge'),
  'username' => env('DB_USERNAME', 'forge'),
  'password' => env('DB_PASSWORD', ''),
  'unix_socket' => env('DB_SOCKET', ''),
  'charset' => 'utf8mb4',
  'collation' => 'utf8mb4_unicode_ci',
  'prefix' => '',
  'prefix_indexes' => true,
  'strict' => true,
  'engine' => null,
  'options' => extension_loaded('pdo_mysql') ? array_filter([
      PDO::MYSQL_ATTR_SSL_CA => env('MYSQL_ATTR_SSL_CA'),
  ]) : [],
],
```

Si bien es cierto que podemos realizar las modificaciones en este archivo, Laravel nos proporciona un archivo `.env` que nos permitirá modificar estas configuraciones de la base de datos.
```conf
APP_NAME=Laravel
APP_ENV=local
APP_KEY=base64:dayllh8BfcNZGvKve2Zd5xd0X4nrpfAdSFoSEfQddnI=
APP_DEBUG=true
APP_URL=http://localhost

LOG_CHANNEL=stack
LOG_DEPRECATIONS_CHANNEL=null
LOG_LEVEL=debug

DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=laravel
DB_USERNAME=root
DB_PASSWORD=

BROADCAST_DRIVER=log
CACHE_DRIVER=file
FILESYSTEM_DISK=local
QUEUE_CONNECTION=sync
SESSION_DRIVER=file
SESSION_LIFETIME=120

MEMCACHED_HOST=127.0.0.1

REDIS_HOST=127.0.0.1
REDIS_PASSWORD=null
REDIS_PORT=6379

MAIL_MAILER=smtp
MAIL_HOST=mailpit
MAIL_PORT=1025
MAIL_USERNAME=null
MAIL_PASSWORD=null
MAIL_ENCRYPTION=null
MAIL_FROM_ADDRESS="hello@example.com"
MAIL_FROM_NAME="${APP_NAME}"

AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=
AWS_USE_PATH_STYLE_ENDPOINT=false

PUSHER_APP_ID=
PUSHER_APP_KEY=
PUSHER_APP_SECRET=
PUSHER_HOST=
PUSHER_PORT=443
PUSHER_SCHEME=https
PUSHER_APP_CLUSTER=mt1

VITE_APP_NAME="${APP_NAME}"
VITE_PUSHER_APP_KEY="${PUSHER_APP_KEY}"
VITE_PUSHER_HOST="${PUSHER_HOST}"
VITE_PUSHER_PORT="${PUSHER_PORT}"
VITE_PUSHER_SCHEME="${PUSHER_SCHEME}"
VITE_PUSHER_APP_CLUSTER="${PUSHER_APP_CLUSTER}"
```
En este archivo podemos ver que tenemos configuraciones de la base de datos:
```conf
. . .

DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=laravel
DB_USERNAME=root
DB_PASSWORD=

. . .
```
Es aquí donde se deben realizar las configuraciones, esto por que nosotros al momento de desarrollo querremos tener diferentes conexiones o configuraciones de entornos, por ejemplo cuando trabajemos de manera local querremos que se conecte a alguna base de datos local, si lo llevamos a producción querremos conectar a otra base de datos, si lo tendriamos todo en el archivo de config `database.php` sera molestoso ir y estar cambiando la misma base de datos

Este archivo .env es muy importante por que aqui se ven las conexiones de SESSION, tambien las de CORREO si es smt el PORT.

### Más

Para conectar tu aplicación Laravel 10 a una base de datos, primero debes configurar la conexión en el archivo .env de tu aplicación. Abre el archivo .env y busca las variables de entorno que comienzan con "DB_". Asegúrate de que estas variables se ajusten a la configuración de tu base de datos:
```conf
DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=nombre_de_la_base_de_datos
DB_USERNAME=nombre_de_usuario
DB_PASSWORD=contraseña
```

En el ejemplo anterior, se utiliza la base de datos MySQL. Si estás utilizando otra base de datos, como PostgreSQL o SQLite, debes cambiar el valor de DB_CONNECTION.

Una vez que hayas configurado la conexión a la base de datos, puedes utilizar el ORM Eloquent de Laravel para interactuar con la base de datos. Eloquent te permite definir modelos que representan tablas de la base de datos y realizar operaciones de CRUD (crear, leer, actualizar y eliminar) en ellas de forma fácil y elegante.

Para comenzar a utilizar Eloquent, primero debes crear un modelo. Puedes generar un modelo utilizando el comando artisan make:model seguido del nombre del modelo. Por ejemplo, si quieres crear un modelo para la tabla "users", puedes ejecutar el siguiente comando:

```
php artisan make:model User
```
Esto creará un archivo User.php en el directorio app/Models de tu aplicación Laravel 10. Abre el archivo y asegúrate de que la clase tenga el siguiente código:
```php
<?php
namespace App\Models;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
class User extends Model
{
   use HasFactory;
}
```
Este modelo representa la tabla "users" en la base de datos y utiliza el trait HasFactory, que proporciona algunos métodos de fábrica útiles para la creación de registros de modelo.

Una vez que hayas creado el modelo, puedes utilizar Eloquent para realizar operaciones de CRUD en la tabla correspondiente. Por ejemplo, para crear un nuevo registro de usuario, puedes hacer lo siguiente:
```php
$user = new User;
$user->name = 'John Doe';
$user->email = 'john@example.com';
$user->save();
```
Este código crea un nuevo objeto User, establece los valores de las propiedades "name" y "email" y luego guarda el objeto en la base de datos utilizando el método save().

Para recuperar todos los registros de usuarios de la tabla "users", puedes hacer lo siguiente:
```php
$users = User::all();
```
Este código recupera todos los registros de la tabla "users" y los devuelve como una colección de objetos User.

Para actualizar un registro de usuario existente, puedes hacer lo siguiente:
```php
$user = User::find(1);
$user->name = 'Jane Doe';
$user->email = 'jane@example.com';
$user->save();
```
Este código busca el registro de usuario con el ID 1, actualiza los valores de las propiedades "name" y "email" y luego guarda el objeto en la base de datos utilizando el método save().

Para eliminar un registro de usuario existente, puedes hacer lo siguiente:
```php
$user = User::find(1);
$user->delete();
```
Este código busca el registro de usuario con el ID 1 y lo elimina de la base de datos utilizando el método delete().

Con Eloquent, puedes realizar operaciones de CRUD en tu base de datos de forma elegante y fácil.

## Introducción a migraciones

Antes en PHP para crear tablas normalmente lo hacias por codigo SQL, o tambien desde la interfaz de tu gestor de base de datos creando asi tablas sus campos, sus tipos de datos como varchar, numeric; si bien es cierto esto es válido, cuando se trabaja en equipos grandes esto no suele ser muy efectivo, puesto que si creamos una tabla tendremos que estar comunicando a cada integrante del equipo que modificamos la base de datos.

Laravel nos ayuda a solucionar este problema mediante las **migraciones** en esencia las migraciones son como el control de versiones para nuestra base de datos

**MIGRACIONES**

Siempre que nosotros iniciemos nuestro proyecto con laravel encontraremos algunas migraciones por default que se encontrara en la ruta: `database/migrations` tendremos 4 migraciones creadas:
```
- create_users_table.php
- create_password_reset_tokens_table.php
- create_failed_jobs_table.php
- create_personal_access_tokens_table.php
```
Al entrar al archivo de `create_users_table.php` veremos que esta es una clase anónima, es una clase anonima porque no tiene un nombre
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('users', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->string('email')->unique();
            $table->timestamp('email_verified_at')->nullable();
            $table->string('password');
            $table->rememberToken();
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('users');
    }
};
```
Se cuenta con dos métodos:
- UP()
- DOWN()

El metodo `up()` se encargara de crear la tabla `'users'` con sus atributos y tipos de datos. Mientras que el método `down()` se encargará de revertir todo lo que haya hecho `up()`

**Explicación del método up()**

1. Crear una nueva tabla
  1. Se importa el facade `use Illuminate\Support\Facades\Schema;`
  2. Se le pasa el método create con el nombre de la tabla y una función anónima
  3. Inyectamos Blueprint
  4. Creamos los campos que se necesitarán
  5. `$table->id();` Es un campo numerado tipo biginteger ademas sera autoincrementado 

En las migraciones pondremos que vamos a realizar en nuestra base de datos, en este caso estamos indicandole crear una tabla. Como la ejecutamos?
```
php artisan migrate
```

Con este comando haremos que laravel lea cada uno de los archivos de la carpeta `database/migrations/`

Si regresamos a nuestra base de datos en nuestro gestor, de lo que la base de datos estaba vacía ahora podremos observar, las nuevas tablas creadas ademas se creará una tabla de Laravel llamada `migrations` en esta tabla se insertará los nombres de las migraciones que tenemos en nuestro proyecto y que se ejecutaron, esta tabla es importante porque a lo largo del desarrollo de la aplicación crearemos nuevas migraciones y al ejecutar el comando no querremos que se vuelvan a ejecutar las que ya se ejecutaron.

El campo batch significa lotes, las migraciones se ejecutan por lotes, es decir la anterior ejecucion fue el lote N° 1 si creamos mas migraciones estos seran nuevos lotes, esto nos ayuda porque si tenemos nuevos lotes como lote 2, lote 3 etc y queremos revertir los cambios pero en la ultima migracion
```
php artisan migrate:rollback
```
Este comando verifica cual es el ultimo lote para ejecutar el método `down()`, en este caso lo que hace es eliminar las tablas

## Crear tablas con migraciones

Crearemos nuestras propias migraciones, simularemos crear un **Blog**

Para crear una migración ejecutamos el siguiente comando:
```
php artisan make:migration nombreTabla
```

Este comando creara una nueva migración en nuestro caso crearemos una tabla `posts` con el nombre: `2024_02_21_182341_posts`

Para seguir una convencion en Laravel, podemos nombrar la tabla de la siguiente forma: `create_posts_table` esto ademas de seguir la convención de Laravel nos creara el archivo mucho mas completo que el anterior, nos pondra la tabla con cierta ayuda.
```
php artisan make:migration create_posts_table
```
nos creará el siguiente archivo un poco mas completo:
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('posts', function (Blueprint $table) {
            $table->id();
            $table->timestamps();// create at update at
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('posts');
    }
};
```
Vemos que el anterior archivo nos implementa el método `up()` con ciertos campos como el id y el timestamps, muy utiles en la mayoria de tablas, ademas nos implementa de una vz el metodo `down()`

Ahora sobre ese archivo ya podemos realizar nuestras modificaciones.
```php
public function up(): void
{
  Schema::create('posts', function (Blueprint $table) {
    $table->id();

    $table->string('title'); // hasta 250 caracteres
    $table->string('slug');
    $table->text('content'); // muchos mas caracteres

    $table->timestamps();
  });
}
```

El siguiente paso es ejecutar la migración
```
php artisan migrate
```

Lo que vemos en esta nueva ejecución es que en la tabla `migrations` la migracion de `create_posts_table` esta en el batch o lote 2.

### Más

Las migraciones son una herramienta de Laravel que te permiten crear, modificar y eliminar tablas en tu base de datos de forma programática y versionada. Esto significa que puedes definir los cambios en la estructura de la base de datos en código y controlar su evolución a través del control de versiones de tu aplicación.

Para crear una migración en Laravel, puedes usar el comando 'make:migrationdatabase/migrations. Por ejemplo, para crear una migración llamada 'create_users_tablecreate_users_table, puedes ejecutar el siguiente comando en tu terminal:

```
php artisan make:migration create_users_table
```
Este comando generará un archivo de migración con un nombre similar a '2023_03_21_000000_create_users_table.php

Una vez que hayas generado la migración, puedes abrir el archivo en tu editor de código y definir la estructura de la tabla que deseas crear. Por ejemplo, para crear una tabla de usuarios con campos de nombre, correo electrónico y contraseña, puedes usar el siguiente código:
```php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
class CreateUsersTable extends Migration
{
   public function up()
   {
       Schema::create('users', function (Blueprint $table) {
           $table->id();
           $table->string('name');
           $table->string('email')->unique();
           $table->string('password');
           $table->timestamps();
       });
   }
   public function down()
   {
       Schema::dropIfExists('users');
   }
}
```
En este ejemplo, la migración crea una tabla 'usersid, «nombrename, 'correo electrónicoemail, 'contraseñapassword y 'marcas de tiempotimestamps. El campo id es una clave primaria que se genera automáticamente, y el campo email tiene un índice único para garantizar que no haya duplicados.

Una vez que hayas definido la migración, puedes ejecutarla en tu base de datos utilizando el comando 'migrate
```
php artisan migrate
```
Este comando creará la tabla de usuarios en tu base de datos y registrar su ejecución en la tabla 'migrationsmigrate:rollback para deshacer los cambios.

Espero que este capítulo te haya ayudado a comprender cómo utilizar las migraciones de Laravel 10 para crear tablas en la base de datos de tu aplicación. En el siguiente capítulo, te mostraré cómo utilizar el ORM Eloquent de Laravel para interactuar con la base de datos.

## Revertir cambios

En sesiones anteriores habiamos visto muy por encima el siguiente comando:
```
php artisan migrate:rollback
```
que nos permitia revertir la ultima migración que habiamos hecho.

Es decir en el proyecto que estabamos avanzando, si ejecutamos el comando veremos que solo se eliminara la tabla `posts` esto porque esta fue la ultima migracion y estaba en el batch 2.

Esto es importante, porque si nosotros al desarrollar queremos hacer un cambio a las ultimas migraciones nos permitira hacer un rollback, corregir y finalmente modificar de nuevo la migración.

**Qué ocurre si el cambio que quiero hacer esta en un batch o lote anterior al último**

La solución que podriamos intuir seria de ejecutar `rollback` las veces que sean necesarias hasta borrar las migraciones que queremos modificar y luego ejecutar el `migrate` para crearlo de nuevo.

**refresh**

Una forma de borrar todas las migraciones de un solo comando podemos escribir:
```
php artisan migrate:refresh
```
Al ejecutar esto lo que pasa es que se leera cada una de las migraciones y ejecutara el comando `down()` una vez ejecutado en todas las migraciones se ejecutará el metodo `up()`

**fresh**

Existe tambien otro comando `migrate:fresh`, la diferencia al anterior es que esta eliminara todas las tablas de la base de datos es decir se hayan creado desde las migraciones o no, luego volvera a crear las migraciones.

Si usamos refresh se mantendran las tablas creadas sin migraciones.

## Actualizar tabla con migraciones

En el capitulo anterior vimos comandos rollback, refresh y fresh. Estos comandos son importantes pero son **destructivos** osea imagina que ya tienes registros en cualquiera de las tablas y ejecutas cualquiera de esos comando por ejemplo **refresh** veras que los registros que tenias se eliminaron, esto puede ser un grave inconveniente.

**¿Cómo hacemos para modificar campos de nuestras tablas sin eliminar los registros?**

Esto también se puede hacer con migraciones, es decir:
```
php artisan make:migration add_slug_to_posts_table
```
Es importante seguir esa convención, la migracion que se esta creando es para agregar el campo slug a la tabla **posts**.

El archivo que crea este comando tiene los metodos `up()` y `down()` también, aqui vemos que se usa el Facade `Schema` con el metodo `table` este se usa para modificar tablas.

```php
up()
Schema::table('posts', function(Blueprint $table) {
  $table->string('slug')
        ->nullable()
        ->unique();
});

down()
Schema::table('posts', function(Blueprint $table) {
  $table->dropColumn('slug');
});
```

Si ejecutamos esta migración, se agregara el campo `slug` en la tabla `posts`, si tenemos registros ya creados el campo debera aceptar valores nulos por que se autocompletara para cada registro un valor `NULL`

**Si queremos ubicar el campo en la posicion indicada en la tabla**
```php
up()
Schema::table('posts', function(Blueprint $table) {
  $table->string('slug')
        ->nullable()
        ->after('title')
        ->unique();
});

down()
Schema::table('posts', function(Blueprint $table) {
  $table->dropColumn('slug');
});
```
Usamos `after` para indicarle que se debe de insertar despues del campo 'title'

### Más

En Laravel 10, puedes revertir cambios en la base de datos utilizando las migraciones. Las migraciones te permiten deshacer y reaplicar los cambios en la base de datos de forma ordenada y controlada.

Para revertir una migración específica, puedes utilizar el comando "rollback" de Artisan. Por ejemplo, si tienes una migración llamada "create_users_table" y deseas revertirla, puedes ejecutar el siguiente comando en la terminal:

```
php artisan migrate:rollback --step=1
```

El parámetro "--step=1" indica que solo se debe revertir la última migración. Si deseas revertir varias migraciones, puedes aumentar el valor de "--step" según el número de migraciones que deseas revertir.

También puedes utilizar el comando "rollback" sin el parámetro "--step" para revertir todas las migraciones que se hayan aplicado. Por ejemplo:

```
php artisan migrate:rollback
```
Si deseas eliminar completamente todas las tablas de la base de datos y revertir todas las migraciones, puedes utilizar el comando "reset". Este comando elimina todas las tablas de la base de datos y luego ejecuta todas las migraciones de nuevo. Para utilizar el comando "reset", puedes ejecutar el siguiente comando en la terminal:
```
php artisan migrate:reset
```
Ten en cuenta que el comando "reset" eliminará todos los datos de la base de datos, por lo que debes tener cuidado al utilizarlo en entornos de producción.

## Renombrar una tabla

Para renombrar nuestra tabla llamada `posts` por el nombre `article`, seguimos estos pasos:
1. Creamos una nueva migración con:
  ```
  php artisan make:migration rename_posts_table
  ```
2. En el cuerpo de la funcion `up()` incluímos:
  ```php
  Schema::rename('posts', 'articles');
  ```
3. En el cuerpo de la función `down()` incluímos
  ```php
  Schema::rename('articles', 'posts');
  ```
Son la misma función, pero invirtiendo los nombres

Finalmente ejecutamos
```
php artisan migrate
```

## Eliminar tablas

Crearemos una migración que se encargue de eliminar una tabla.

```
php artisan make:migration drop_posts_table
```

en el archivo creado:
```php
up()
Schema::dropIfExists('posts');

down()
Schema::create('posts', function (Blueprint $table) {
  $table->id();

  $table->string('title'); // hasta 250 caracteres
  $table->string('slug');
  $table->longText('body'); // muchos mas caracteres

  $table->timestamps();

});
```

## Tipos de datos

```php
public function up(): void
{
  Schema::create('data', function (Blueprint $table) {
    $table->id(); // 0 a 4294967295

    $table->integer('user_id'); // -2147483648 a 2147483647
    $table->bigInteger('user_id2'); // -9223372036854775808 a 9223372036854775807
    $table->boolean('is_active'); // 0 o 1
    $table->dateTime('created_at'); // 1970-01-01 00:00:00 a 2038-01-19 03:14:07
    $table->date('created_at2'); // 1970-01-01 a 2038-01-19
    $table->time('created_at3'); // 00:00:00 a 23:59:59
    $table->decimal('price', 5, 2); // 0.00 a 99999.99
    $table->double('price2', 5, 2); // 0.00 a 999999999999.99
    $table->enum('color', ['red', 'green', 'blue']); // red, green o blue
    $table->float('price3', 5, 2); // 0.00 a 9999.99
    $table->foreignId('category_id') // 0 a 4294967295
          ->unsigned();
    $table->bigIncrements('id'); // 1 a 18446744073709551615
    $table->json('data'); // { "key": "value" }, se puede almacenar arrays
    $table->string('name'); // hasta 255 caracteres, es un varchar
    $table->string('slug', 100); // hasta 100 caracteres
    $table->text('description'); // hasta 65535 caracteres
    $table->mediumText('description2'); // hasta 16777215 caracteres
    $table->longText('description3'); // hasta 4294967295 caracteres
    $table->morphs('taggable'); // 'taggable_id' y 'taggable_type' (relaciones polimorficas)

    $table->timestamps(); // created_at y updated_at (creado y actualizado)
  });
}
```

### Más
Ups los encontre→ [Listado](https://styde.net/laravel-6-doc-base-de-datos-migraciones/)

```php
$table->bigIncrements('id');	            // Tipo de columna equivalente a auto-incremento UNSIGNED BIGINT (clave primaria).
$table->bigInteger('votes');	            // Tipo de columna equivalente a BIGINT.
$table->binary('data');	                  // Tipo de columna equivalente a BLOB.
$table->boolean('confirmed');	            // Tipo de columna equivalente a BOOLEAN.
$table->char('name', 100);	              // Tipo de columna equivalente a CHAR con una longitud.
$table->date('created_at');	              // Tipo de columna equivalente a DATE.
$table->dateTime('created_at', 0);	      // Tipo de columna equivalente a DATETIME con precisión (dígitos totales).
$table->dateTimeTz('created_at', 0);	    // Tipo de columna equivalente a DATETIME (con zona horaria) con precisión (dígitos totales).
$table->decimal('amount', 8, 2);	        // Tipo de columna equivalente a DECIMAL con una precisión (el total de dígitos) y escala de dígitos decimales.
$table->double('amount', 8, 2);	          // Tipo de columna equivalente a DOUBLE con una precisión (el total de dígitos) y escala de dígitos decimales.
$table->enum('level', ['easy', 'hard']);	// Tipo de columna equivalente a ENUM.
$table->float('amount', 8, 2);	          // Tipo de columna equivalente a FLOAT con una precisión (el total de dígitos) y escala de dígitos decimales.
$table->geometry('positions');	          // Tipo de columna equivalente a GEOMETRY.
$table->geometryCollection('positions');	// Tipo de columna equivalente a GEOMETRYCOLLECTION.
$table->increments('id');	                // Tipo de columna equivalente a auto-incremento UNSIGNED INTEGER (clave primaria).
$table->integer('votes');	                // Tipo de columna equivalente a INTEGER.
$table->ipAddress('visitor');	            // Tipo de columna equivalente a dirección IP.
$table->json('options');	                // Tipo de columna equivalente a JSON.
$table->jsonb('options');	                // Tipo de columna equivalente a JSONB.
$table->lineString('positions');	        // Tipo de columna equivalente a LINESTRING.
$table->longText('description');	        // Tipo de columna equivalente a LONGTEXT.
$table->macAddress('device');	            // Tipo de columna equivalente a dirección MAC.
$table->mediumIncrements('id');	          // Tipo de columna equivalente a auto-incremento UNSIGNED MEDIUMINT (clave primaria).
$table->mediumInteger('votes');	          // Tipo de columna equivalente a MEDIUMINT.
$table->mediumText('description');	      // Tipo de columna equivalente a MEDIUMTEXT.
$table->morphs('taggable');	              // Agrega los tipos de columna equivalente a UNSIGNED BIGINT taggable_id y VARCHAR taggable_type.
$table->uuidMorphs('taggable');	          // Agrega las columnas UUID equivalentes taggable_id CHAR(36) y taggable_type VARCHAR(255).
$table->multiLineString('positions');	    // Tipo de columna equivalente a MULTILINESTRING.
$table->multiPoint('positions');	        // Tipo de columna equivalente a MULTIPOINT.
$table->multiPolygon('positions');	      // Tipo de columna equivalente a MULTIPOLYGON.
$table->nullableMorphs('taggable');	      // Agrega versiones nullable de las columnas morphs().
$table->nullableUuidMorphs('taggable');	  // Agrega versiones nullable de las columnas uuidMorphs().
$table->nullableTimestamps(0);	          // Alias del método timestamps().
$table->point('position');	              // Tipo de columna equivalente a POINT.
$table->polygon('positions'); 	          // Tipo de columna equivalente a POLYGON.
$table->rememberToken();	                // Agrega un tipo de columna equivalente a VARCHAR(100) que permita nulos para remember_token.
$table->set('flavors', ['strawberry', 'vanilla']);	//Tipo de columna equivalente a SET.
$table->smallIncrements('id');	          //Tipo de columna equivalente a auto-incremento UNSIGNED SMALLINT (clave primaria).
$table->smallInteger('votes');	          //Tipo de columna equivalente a SMALLINT.
$table->softDeletes(0);	                  //Agrega un tipo de columna equivalente a TIMESTAMP que permita nulos para deleted_at en eliminaciones lógicas con precisión (dígitos totales).
$table->softDeletesTz(0); 	              //Agrega un tipo de columna equivalente a TIMESTAMP que permita nulos para deleted_at (con la zona horaria) en eliminaciones lógicas con precisión (dígitos totales).
$table->string('name', 100);	            //Tipo de columna equivalente a VARCHAR con una longitud.
$table->text('description');	            //Tipo de columna equivalente a TEXT.
$table->time('sunrise', 0);	              //Tipo de columna equivalente a TIME con precisión (dígitos totales).
$table->timeTz('sunrise', 0);	            //Tipo de columna equivalente a TIME (con la zona horaria) con precisión (dígitos totales).
$table->timestamp('added_on', 0);	        //Tipo de columna equivalente a TIMESTAMP con precisión (dígitos totales).
$table->timestampTz('added_on', 0); 	    //Tipo de columna equivalente a TIMESTAMP (con la zona horaria) con precisión (dígitos totales).
$table->timestamps(0);	                  //Agrega los tipos de columnas equivalentes a TIMESTAMP que permitan nulos para created_at y updated_at con precisión (dígitos totales).
$table->timestampsTz(0);	                //Agrega los tipos de columnas equivalentes a TIMESTAMP (con la zona horaria) que permitan nulos para created_at y updated_at con precisión (dígitos totales).
$table->tinyIncrements('id');	            //Tipo de columna equivalente a auto-incremento UNSIGNED TINYINT (clave primaria).
$table->tinyInteger('votes');	            //Tipo de columna equivalente a TINYINT.
$table->unsignedBigInteger('votes');	    //Tipo de columna equivalente a UNSIGNED BIGINT.
$table->unsignedDecimal('amount', 8, 2);	//Tipo de columna equivalente a UNSIGNED DECIMAL con una precisión (total de dígitos) escala (dígitos decimales).
$table->unsignedInteger('votes');	        //Tipo de columna equivalente a UNSIGNED INTEGER.
$table->unsignedMediumInteger('votes');	  //Tipo de columna equivalente a UNSIGNED MEDIUMINT.
$table->unsignedSmallInteger('votes');	  //Tipo de columna equivalente a UNSIGNED SMALLINT.
$table->unsignedTinyInteger('votes');	    //Tipo de columna equivalente a UNSIGNED TINYINT.
$table->uuid('id'); 	                    //Tipo de columna equivalente a UUID.
$table->year('birth_year');	              //Tipo de columna equivalente a YEAR.
```

## Modificadores de columna

En este capítulo, te enseñaremos cómo utilizar los modificadores de columna en las migraciones de Laravel 10. Los modificadores de columna son una forma poderosa de definir restricciones y valores predeterminados para los campos de la tabla en la base de datos de tu aplicación Laravel.

Los modificadores de columna te permiten especificar restricciones para los campos de la tabla, como la longitud máxima de un campo o si un campo es obligatorio o no. Además, también puedes utilizar los modificadores de columna para establecer valores predeterminados para los campos, lo que significa que si no se proporciona ningún valor, se utilizará el valor predeterminado que hayas establecido.

En Laravel 10, puedes utilizar varios tipos de modificadores de columna para definir las restricciones y valores predeterminados de los campos de la tabla. Algunos de los modificadores más comunes incluyen "nullable", que permite que un campo tenga un valor nulo, "unique", que asegura que un campo tenga un valor único, y "default", que establece un valor predeterminado para un campo.

Además, Laravel también ofrece modificadores de columna personalizados que puedes utilizar para definir restricciones y valores predeterminados específicos para tu aplicación. Con los modificadores de columna personalizados, puedes definir tus propias reglas de validación y valores predeterminados para los campos de la tabla.

En resumen, los modificadores de columna en las migraciones de Laravel 10 son una herramienta poderosa para definir restricciones y valores predeterminados para los campos de la tabla en la base de datos de tu aplicación. Con los modificadores de columna, puedes establecer reglas de validación específicas y asegurarte de que los datos almacenados en tu base de datos cumplan con tus requisitos. Si deseas definir reglas de validación y valores predeterminados para los campos de la tabla en tu aplicación Laravel, es fundamental que aprendas cómo utilizar los modificadores de columna.

**default**

```php
public function up(): void
{
  Schema::create('data', function (Blueprint $table) {
    $table->id();

    $table->string('name')
          ->default('Victor Arana');
    
    $table->boolean('is_active')
          ->default(false);

    $table->timestamps();
  });
}
```

Nos permite darle un valor por defecto a nuestras columnas

**nullable()**

Nos permite decir que un campo no es obligatorio
```php
public function up(): void
{
  Schema::create('data', function (Blueprint $table) {
    $table->id();
    
    $table->text('description')
          ->nullable();

    $table->timestamps();
  });
}
```

**unsigned()**

Indica que el campo debe de tener solo numeros positivos
```php
public function up(): void
{
  Schema::create('data', function (Blueprint $table) {
    $table->id();
    
    $table->integer('edad')
          ->unsigned();

    $table->timestamps();
  });
}
```

**useCurrent()**

Indica que al campo se le asignara la fecha actual
```php
public function up(): void
{
  Schema::create('data', function (Blueprint $table) {
    $table->id();
    
    $table->timestamps('published_at')
          ->useCurrent();

    $table->timestamps();
  });
}
```
**after()**

Cuando vamos a modificar una tabla podemos indicar despues de que campo insertaremos nuestro campo modificado

```php
public function up(): void
{
  Schema::create('data', function (Blueprint $table) {
    $table->id();
    
    $table->boolean('active')
          ->after('name');

    $table->timestamps();
  });
}
```
Si le ponemos **first()** se pondra al inicio de los campos de la tabla

## Modificar columnas

si queremos modificar el campo de alguna de las tablas podemos crear una nueva migracion:
```
php artisan make:migration alter_to_posts_table
```
y en la migración que se creo hacemos:
```php
Schema::table('posts', function(Blueprint $table) {
  $table->mediumText('body')
        ->change();
});
```
Ahora es importante que si nuestro campo tenia mas de un modificador, en la migracion de alter deberíamos agregarlo tambien

En el método **down()** lo que pondriamos sería el valor inicial del campo en la tabla.

### Más

En este capítulo, te mostraremos cómo puedes modificar las columnas existentes en las tablas de la base de datos de tu aplicación Laravel 10 utilizando las migraciones. Las migraciones de Laravel te permiten realizar cambios en la estructura de tus tablas de manera fácil y segura, y modificar las columnas existentes es una tarea común en la administración de la base de datos de tu aplicación.

Con las migraciones de Laravel, puedes cambiar el tipo de datos de los campos existentes, modificar las restricciones y valores predeterminados de los campos, y agregar o eliminar índices de los campos. Por ejemplo, si necesitas cambiar el tipo de datos de un campo, puedes utilizar una migración para modificar el tipo de datos de la columna y actualizar la estructura de la tabla.

Modificar las restricciones y valores predeterminados de los campos también es una tarea que se puede realizar utilizando las migraciones de Laravel. Si necesitas cambiar la longitud máxima de un campo o establecer un nuevo valor predeterminado para un campo existente, puedes utilizar una migración para modificar las restricciones y valores predeterminados de la columna.

Además, si necesitas agregar o eliminar índices de los campos, también puedes hacerlo utilizando las migraciones de Laravel. Los índices pueden mejorar el rendimiento de tu aplicación al acelerar las búsquedas en la base de datos.

En resumen, modificar las columnas existentes en las tablas de la base de datos de tu aplicación Laravel 10 es una tarea común en la administración de la base de datos de tu aplicación. Las migraciones de Laravel te permiten realizar cambios en la estructura de tus tablas de manera fácil y segura, y modificar las columnas existentes es una tarea que puedes realizar con las migraciones. Si necesitas cambiar el tipo de datos, modificar las restricciones y valores predeterminados o agregar o eliminar índices de los campos, las migraciones de Laravel son una herramienta fundamental que debes aprender a utilizar.

## Renombrar columnas
Podemos usar la anterior migracion `alter`
```php
Schema::table('posts', function(Blueprint $table) {
  $table->renameColumn('nombreAnterior', 'nombreActualizado');
});
```

Si ejecutamos esta migración nos dará un error, esto porque para realizar este rename debemos instalar un paquete:
```
composer require doctrine/dbal
```

## Eliminar una columna

Podemos usar la anterior migracion `alter`
```php
Schema::table('posts', function(Blueprint $table) {
  $table->dropColumn('slug');
});
```

## Índices

**Índice primario**
```php
$table->id();
```
A continuación se muestra que es lo que realiza el tipo de dato **id()**
```php
$table->bigInteger('id')
      ->autoIncrement()
      ->unsigned();

// índice
$table->primary('id');
```
Es importante saber que el autoIncrement() asigna el modificador primary() por lo que tendremos que comentarlo, ya que no podemos asignar a una tabla mas de un campo con llave primaria

Otra forma es la siguiente
```php
$table->bigIncrements('id');
```

Y otra forma es la siguiente:
```php
$table->increments('id'); // le asigna todo igual solo que usa un int
```

**LLAVES PRIMARIAS COMPUESTAS**

```php
$table->primary(['id', 'slug'])
```

**INDICES ÚNICOS**

Nos permite que el campo no debe de tener valores repetidos
```php
$table->string('name')->unique();
```

**INDICE**

Nos ayuda en la búsqueda
```php
$table->index('title');
```

**INDICES FULLTEXT**
```php
$table->fullText('body');
```

## Eliminar Índices

Habra ocasiones en las que querremos eliminar indices:

Creamos una nueva migracion
```
php artisan make:migration alter_to_post_table
```

```php
Schema::table('posts', function(Blueprint $table) {
  $table->dropUnique('posts_slug_unique');
  $table->dropIndex('posts_title_index');
  $table->dropFullText('posts_body_fulltext');

  $table->dropPrimary('PRIMARY'); // ELIMINAR LA LLAVE PRIMARY
});
```

## Llaves foráneas

Las llaves foraneas es: colocar las llaves primarias en otra tabla.

Imaginemos que tenemos la tabla posts, y la tabla escritor; entonces un escritor estará en un posts.

```php
Schema::create('posts', function (Blueprint $table) {
  $table->id();

  $table->string('title'); // hasta 250 caracteres
  $table->string('slug')
        ->unique();
  $table->longText('body'); // muchos mas caracteres
  $table->timestamp('published_at');

  $table->bigInteger('user_id')
        ->unsigned();

  $table->timestamps();

});
```

Otra forma:
```php
$table->unsignedBigInteger('user_id');
```
Cuando trabajamos con llaves foraneas, lo que debemos hacer es que los tipos de datos en ambas tablas deben de ser las mismas.

**AGREGANDO RESTRICCION DE LLAVE FORANEA**

Esta restricción lo único que hace es validar que el dato que se inserte de la otra tabla, realmente exista.

```php
Schema::create('posts', function (Blueprint $table) {
  $table->id();

  $table->string('title'); // hasta 250 caracteres
  $table->string('slug')
        ->unique();
  $table->longText('body'); // muchos mas caracteres
  $table->timestamp('published_at');

  $table->unsignedBigInteger('user_id');

  $table->foreign('user_id') // Nos permitirá agregar id que esten en users
        ->references('id')
        ->on('users');

  $table->timestamps();

});
```

Otra forma resumida
```php
$table->foreignId('user_id')
      ->constrained();
```
el constrained permite la validación de que existe el id en users

**QUE PASA SI UN POSTS TIENE ID_USER=10, PERO MAS ADELANTE ESE USER SE DA DE BAJA**

Nos interesa que cuando se elimine un user entonces el post tambien se elimine:

```php
$table->foreignId('user_id')
      ->constrained()
      ->onDelete('cascade');
```
tambien:
```php
$table->foreignId('user_id')
      ->constrained()
      ->cascadeOnDelete();
```

`onDelete('set null')` lo que indica esto es que cuando se elimine el user con id=10 todos los posts se queden con null en este campo, para eso debemos agregarle también el modificador `nullable()`

**QUE PASA SI EL USER CAMBIA DE ID, NUESTRO USER_ID DE LA TABLA POST SE QUEDARA CON ID QUE POSIBLEMENTE DEJE DE EXISTIR**

Nos interesa que al momento de que se cambie de id el user los post tambien se cambien al nuevo id

```php
$table->foreignId('user_id')
      ->constrained()
      ->onDelete('cascade')
      ->onUpdate('cascade');
```
hacemos uso de `onUpdate()`

**AGREGAR OTRA LLAVE FORANEA**

```
php artisan make:migration create_categories_table
```
En nuestra tabla `posts`
```php
$table->foreignId('user_id')
      ->constrained()
      ->onDelete('cascade')
      ->onUpdate('cascade');

$table->foreignId('category_id')
      ->constrained()
      ->onDelete('cascade')
      ->onUpdate('cascade');
```

> Al momento de crear nuestras migraciones debemos tener muy en cuenta el orden, si queremos cambiar de orden podemos renombrar nuestra migracion con otro nombre para que se ejecute antes

## Eliminar llaves foraneas

En el capitulo anterior vimos que se podian agregar restricciones de clave foranea, ademas vimos que se agregaron algunas indices:
```
posts_user_id_foreign
posts_category_id_foreign
```

Para eliminar las restricciones (relaciones entre tablas)
```php
up()
Schema::table('posts', function(Blueprint $table) {
  $table->dropForeign('posts_category_id_foreign');
  // tambien se puede
  $table->dropForeign(['posts_category_id_foreign']);
  $table->dropForeign(['posts_user_id_foreign']);
});

down()
$table->foreign('user_id')
      ->references('id')
      ->on('users')
      ->onDelete('cascade')
      ->onUpdate('cascade');

$table->foreign('category_id')
      ->references('id')
      ->on('users')
      ->onDelete('cascade')
      ->onUpdate('cascade');
```

